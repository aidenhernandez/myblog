# Blog Backend - Technical Architecture

**Version**: 1.0
**Date**: 2025-10-29
**Project**: Blog Backend (Rust/Axum API)
**Project Level**: 3 (Complex System)
**Author**: Generated by BMAD Method v6 - Architect Agent

---

## Executive Summary

This document defines the technical architecture for the Blog Backend API, a Rust-based RESTful service powering a blog social platform. The architecture follows a layered pattern with Axum web framework, MySQL database, JWT authentication, and comprehensive social features (posts, comments, likes, follows, notifications).

All architectural decisions documented here are **MANDATORY** for all AI agents implementing features. These decisions ensure consistency, prevent integration conflicts, and maintain code quality across the entire system.

---

## Table of Contents

1. [Architecture Decision Summary](#architecture-decision-summary)
2. [Technology Stack](#technology-stack)
3. [Project Structure](#project-structure)
4. [Database Architecture](#database-architecture)
5. [API Design](#api-design)
6. [Authentication & Authorization](#authentication--authorization)
7. [Error Handling](#error-handling)
8. [Request Validation](#request-validation)
9. [CORS Configuration](#cors-configuration)
10. [Logging Strategy](#logging-strategy)
11. [Testing Strategy](#testing-strategy)
12. [Connection Pool Configuration](#connection-pool-configuration)
13. [Implementation Patterns](#implementation-patterns)
14. [Epic to Architecture Mapping](#epic-to-architecture-mapping)
15. [Security Architecture](#security-architecture)
16. [Performance Considerations](#performance-considerations)
17. [Development Environment](#development-environment)
18. [Architecture Decision Records](#architecture-decision-records)

---

## Architecture Decision Summary

| # | Decision Category | Decision | Rationale | Affects Epics |
|---|-------------------|----------|-----------|---------------|
| 1 | Database Migrations | sqlx migrations in `migrations/` directory | Built-in, compile-time checked, simple CLI | All |
| 2 | Error Handling | Custom Error Enum with `thiserror` | Type-safe, different HTTP codes per error type, professional API | All |
| 3 | JWT Structure | Minimal payload (user_id only), 24h expiration, no refresh tokens | Fast verification, simple MVP, secure | Auth, All Protected Routes |
| 4 | API Response Format | Direct RESTful responses with HTTP status codes | Standard pattern, no redundancy, easy frontend integration | All |
| 5 | Authentication Flow | JWT middleware extracts user_id, injected into handlers | Centralized validation, clean handler signatures | Auth, All Protected Routes |
| 6 | Request Validation | `validator` crate with derive macros | Declarative, automatic, reduces code duplication | All POST/PUT endpoints |
| 7 | Database Naming | snake_case for all tables/columns | SQL standard, cross-database compatibility | All Database Operations |
| 8 | API Endpoint Naming | RESTful: plural nouns, nested resources | Industry standard, predictable, clean | All API Routes |
| 9 | CORS Configuration | Environment-based origins from env var | Flexible dev, secure production | All API Routes |
| 10 | Logging Strategy | `tracing` crate with RUST_LOG env var | Structured, filterable, performant | All |
| 11 | Testing Strategy | Unit tests (high), Integration tests (medium) | Focus on critical paths for MVP | All |
| 12 | Connection Pool | Configurable size (default 20), 30s timeout | Balanced performance and resource usage | All Database Operations |

---

## Technology Stack

### Core Dependencies

| Technology | Version | Purpose | Configuration |
|------------|---------|---------|---------------|
| **Rust** | 1.70+ | Systems programming language | Edition 2021 |
| **Axum** | 0.7 | Async web framework | Built on tokio/tower |
| **Tokio** | 1.x | Async runtime | Full features enabled |
| **MySQL** | 8.0+ | Relational database | InnoDB engine |
| **sqlx** | 0.7 | Database library | runtime-tokio-rustls, compile-time checking |
| **serde** | 1.0 | Serialization | JSON via serde_json |
| **jsonwebtoken** | 9.2 | JWT authentication | HS256 algorithm |
| **bcrypt** | 0.15 | Password hashing | Cost factor 12 (default) |
| **validator** | 0.18 | Request validation | Derive macros |
| **thiserror** | 1.0 | Error handling | Custom error types |
| **anyhow** | 1.0 | Error context | Application errors |
| **tracing** | 0.1 | Structured logging | With tracing-subscriber |
| **tower-http** | 0.5 | HTTP middleware | CORS, tracing |
| **chrono** | 0.4 | Date/time | With serde support |
| **uuid** | 1.6 | UUID generation | v4 support |
| **dotenv** | 0.15 | Environment variables | .env file loading |

### Development Tools

- **cargo** - Build tool and package manager
- **cargo-watch** (optional) - Auto-reload on file changes
- **sqlx-cli** - Database migration tool

---

## Project Structure

```
backend/
├── Cargo.toml                 # Dependencies and project metadata
├── .env                       # Environment variables (not in git)
├── .env.example               # Environment variable template
├── README.md                  # Project documentation
├──docs/
│   ├── architecture.md        # This file
│   └── stories/               # Implementation stories (Phase 4)
├── migrations/                # sqlx database migrations
│   ├── 20251029000001_create_users_table.sql
│   ├── 20251029000002_create_posts_table.sql
│   └── ...
├── src/
│   ├── main.rs                # Application entry point
│   │                          # - Initialize tracing
│   │                          # - Load .env
│   │                          # - Create DB pool
│   │                          # - Build router with all routes
│   │                          # - Start server
│   │
│   ├── db/
│   │   └── mod.rs             # Database connection pool setup
│   │
│   ├── models/                # Database models (structs)
│   │   ├── mod.rs             # Re-exports all models
│   │   ├── user.rs            # User model + DTOs
│   │   ├── post.rs            # Post model + DTOs
│   │   ├── comment.rs         # Comment model + DTOs
│   │   ├── like.rs            # Like model
│   │   ├── follow.rs          # Follow model
│   │   ├── tag.rs             # Tag model
│   │   ├── post_tag.rs        # PostTag junction model
│   │   └── notification.rs    # Notification model + DTOs
│   │
│   ├── handlers/              # Request handlers (business logic)
│   │   ├── mod.rs             # Re-exports all handlers
│   │   ├── auth.rs            # register, login, logout
│   │   ├── user.rs            # get_profile, update_profile, delete_account
│   │   ├── post.rs            # CRUD, feed, search
│   │   ├── comment.rs         # CRUD comments
│   │   ├── like.rs            # like/unlike posts
│   │   ├── follow.rs          # follow/unfollow users
│   │   ├── notification.rs    # get notifications, mark read
│   │   └── tag.rs             # get tags, posts by tag
│   │
│   ├── routes/                # Route definitions
│   │   ├── mod.rs             # Re-exports all route modules
│   │   ├── auth.rs            # Auth routes (/api/v1/auth/*)
│   │   ├── user.rs            # User routes (/api/v1/users/*)
│   │   ├── post.rs            # Post routes (/api/v1/posts/*)
│   │   ├── comment.rs         # Comment routes
│   │   ├── notification.rs    # Notification routes
│   │   └── tag.rs             # Tag routes
│   │
│   ├── middleware/            # HTTP middleware
│   │   ├── mod.rs             # Re-exports all middleware
│   │   ├── auth.rs            # JWT authentication middleware
│   │   └── cors.rs            # CORS configuration
│   │
│   └── utils/                 # Utility functions
│       ├── mod.rs             # Re-exports all utils
│       ├── error.rs           # Custom error types (ApiError enum)
│       ├── jwt.rs             # JWT creation and validation
│       ├── password.rs        # Password hashing and verification
│       └── validation.rs      # Custom validation helpers
│
└── tests/                     # Integration tests
    ├── integration_tests.rs   # Handler tests
    └── fixtures/              # Test data
```

---

## Database Architecture

### Schema Overview

8 tables with relationships supporting social features:

```
users ──┬─< posts ──┬─< comments
        │           ├─< likes
        │           └─< post_tags >─ tags
        │
        ├─< follows (self-referential)
        └─< notifications
```

### Tables

#### users
```sql
CREATE TABLE users (
    id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    display_name VARCHAR(100),
    bio TEXT,
    profile_picture_url VARCHAR(500),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,

    INDEX idx_username (username),
    INDEX idx_email (email)
);
```

#### posts
```sql
CREATE TABLE posts (
    id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    author_id BIGINT UNSIGNED NOT NULL,
    title VARCHAR(200) NOT NULL,
    content LONGTEXT NOT NULL,
    cover_image_url VARCHAR(500),
    status ENUM('draft', 'published') DEFAULT 'draft',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    published_at TIMESTAMP NULL,

    FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_author_id (author_id),
    INDEX idx_status (status),
    INDEX idx_published_at (published_at),
    INDEX idx_created_at (created_at)
);
```

#### comments
```sql
CREATE TABLE comments (
    id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    post_id BIGINT UNSIGNED NOT NULL,
    author_id BIGINT UNSIGNED NOT NULL,
    content TEXT NOT NULL,
    parent_comment_id BIGINT UNSIGNED NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
    FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_comment_id) REFERENCES comments(id) ON DELETE CASCADE,
    INDEX idx_post_id (post_id),
    INDEX idx_author_id (author_id),
    INDEX idx_parent_comment_id (parent_comment_id)
);
```

#### likes
```sql
CREATE TABLE likes (
    id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    post_id BIGINT UNSIGNED NOT NULL,
    user_id BIGINT UNSIGNED NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE KEY unique_post_like (post_id, user_id),
    INDEX idx_post_id (post_id),
    INDEX idx_user_id (user_id)
);
```

#### follows
```sql
CREATE TABLE follows (
    id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    follower_id BIGINT UNSIGNED NOT NULL,
    following_id BIGINT UNSIGNED NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (follower_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (following_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE KEY unique_follow (follower_id, following_id),
    INDEX idx_follower_id (follower_id),
    INDEX idx_following_id (following_id)
);
```

#### tags
```sql
CREATE TABLE tags (
    id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) UNIQUE NOT NULL,
    slug VARCHAR(50) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_slug (slug)
);
```

#### post_tags (junction table)
```sql
CREATE TABLE post_tags (
    post_id BIGINT UNSIGNED NOT NULL,
    tag_id BIGINT UNSIGNED NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (post_id, tag_id),
    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);
```

#### notifications
```sql
CREATE TABLE notifications (
    id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT UNSIGNED NOT NULL,
    type ENUM('like', 'comment', 'follow', 'reply') NOT NULL,
    actor_id BIGINT UNSIGNED NOT NULL,
    post_id BIGINT UNSIGNED NULL,
    comment_id BIGINT UNSIGNED NULL,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (actor_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
    FOREIGN KEY (comment_id) REFERENCES comments(id) ON DELETE CASCADE,
    INDEX idx_user_id (user_id),
    INDEX idx_is_read (is_read),
    INDEX idx_created_at (created_at)
);
```

### Migration Strategy

**MANDATORY**: All schema changes MUST use sqlx migrations.

```bash
# Create new migration
sqlx migrate add create_users_table

# Run migrations
sqlx migrate run

# Revert last migration
sqlx migrate revert
```

**Migration file naming**: `{timestamp}_{description}.sql`

**Example**: `20251029000001_create_users_table.sql`

---

## API Design

### Base URL

```
http://localhost:8080/api/v1
```

### RESTful Endpoint Patterns

**MANDATORY Rules**:
- Resource names: PLURAL nouns (`/users`, not `/user`)
- URL structure: `/api/v1/{resource}` or `/api/v1/{resource}/{id}`
- Nested resources: `/api/v1/{parent}/{id}/{child}`
- Actions: POST/DELETE for non-CRUD operations (`/posts/:id/like`)

### Complete API Specification

#### Authentication Endpoints (Public)

```
POST   /api/v1/auth/register          Register new user
POST   /api/v1/auth/login             Login user
POST   /api/v1/auth/logout            Logout user (clears token)
POST   /api/v1/auth/forgot-password   Request password reset
POST   /api/v1/auth/reset-password    Reset password with token
```

#### User Endpoints

```
GET    /api/v1/users/:id              Get user profile (public)
PUT    /api/v1/users/:id              Update user profile (protected, own profile)
DELETE /api/v1/users/:id              Delete user account (protected, own account)
GET    /api/v1/users/:id/posts        Get user's posts (public)
GET    /api/v1/users/:id/followers    Get user's followers (public)
GET    /api/v1/users/:id/following    Get users being followed (public)
POST   /api/v1/users/:id/follow       Follow a user (protected)
DELETE /api/v1/users/:id/follow       Unfollow a user (protected)
```

#### Post Endpoints

```
GET    /api/v1/posts                  List all published posts (public, paginated)
GET    /api/v1/posts/:id              Get single post (public if published)
POST   /api/v1/posts                  Create new post (protected)
PUT    /api/v1/posts/:id              Update post (protected, own post)
DELETE /api/v1/posts/:id              Delete post (protected, own post)
GET    /api/v1/posts/feed             Get personalized feed (protected)
GET    /api/v1/posts/search           Search posts (public, query: ?q=keyword)
```

#### Comment Endpoints

```
GET    /api/v1/posts/:id/comments     Get post comments (public)
POST   /api/v1/posts/:id/comments     Create comment (protected)
PUT    /api/v1/comments/:id           Update comment (protected, own comment)
DELETE /api/v1/comments/:id           Delete comment (protected, own comment or post author)
```

#### Like Endpoints

```
POST   /api/v1/posts/:id/like         Like a post (protected)
DELETE /api/v1/posts/:id/like         Unlike a post (protected)
GET    /api/v1/posts/:id/likes        Get post likes (public)
```

#### Notification Endpoints

```
GET    /api/v1/notifications          Get user notifications (protected)
PUT    /api/v1/notifications/:id/read Mark notification as read (protected)
PUT    /api/v1/notifications/read-all Mark all notifications as read (protected)
```

#### Tag Endpoints

```
GET    /api/v1/tags                   Get all tags (public)
GET    /api/v1/tags/:id/posts         Get posts by tag (public)
```

### Request/Response Formats

#### Success Response

Return data directly with appropriate HTTP status code:

```json
// GET /api/v1/users/123 (200 OK)
{
  "id": 123,
  "username": "adan",
  "display_name": "Adan Hernandez",
  "bio": "Software developer",
  "created_at": "2025-10-29T12:00:00Z"
}
```

```json
// POST /api/v1/posts (201 Created)
{
  "id": 456,
  "title": "My First Post",
  "content": "Hello world!",
  "author_id": 123,
  "status": "draft",
  "created_at": "2025-10-29T12:30:00Z"
}
```

```json
// DELETE /api/v1/posts/456 (204 No Content)
// Empty response body
```

#### Error Response

```json
// 404 Not Found
{
  "error": "Post not found with id 456",
  "status": 404
}
```

```json
// 401 Unauthorized
{
  "error": "Invalid or expired token",
  "status": 401
}
```

```json
// 400 Bad Request
{
  "error": "Validation failed: title must be between 1 and 200 characters",
  "status": 400
}
```

### HTTP Status Codes

**MANDATORY Usage**:

- `200 OK` - Successful GET/PUT requests
- `201 Created` - Successful POST that creates a resource
- `204 No Content` - Successful DELETE
- `400 Bad Request` - Validation errors, malformed requests
- `401 Unauthorized` - Missing or invalid JWT token
- `403 Forbidden` - Valid token but insufficient permissions
- `404 Not Found` - Resource doesn't exist
- `409 Conflict` - Duplicate resource (e.g., username taken)
- `500 Internal Server Error` - Unexpected server errors
- `503 Service Unavailable` - Database pool exhausted

---

## Authentication & Authorization

### JWT Token Structure

**Claims**:
```json
{
  "sub": "123",           // user_id as string
  "exp": 1735488000      // expiration timestamp (24 hours from issue)
}
```

**Configuration**:
- Algorithm: HS256
- Secret: Read from `JWT_SECRET` env var
- Expiration: Read from `JWT_EXPIRATION` env var (default: 86400 seconds = 24 hours)

### Authentication Flow

#### Registration Flow
```
1. User sends POST /api/v1/auth/register with {username, email, password}
2. Validate email format, password strength, unique username/email
3. Hash password with bcrypt (cost factor 12)
4. Insert user into database
5. Generate JWT token
6. Return {user, token}
```

#### Login Flow
```
1. User sends POST /api/v1/auth/login with {email, password}
2. Query user by email
3. Verify password with bcrypt
4. Generate JWT token
5. Return {user, token}
```

#### Protected Endpoint Flow
```
1. Client sends request with Authorization: Bearer <token>
2. Auth middleware extracts and validates token
3. Middleware extracts user_id from token claims
4. Middleware injects user_id into request
5. Handler receives authenticated user_id
6. Handler processes business logic
```

### Auth Middleware Implementation

**Location**: `src/middleware/auth.rs`

**Responsibilities**:
1. Extract JWT from `Authorization` header (format: `Bearer <token>`)
2. Validate token signature using `JWT_SECRET`
3. Check token expiration
4. Extract `user_id` from claims
5. Make `user_id` available to handlers
6. Return 401 if token missing/invalid/expired

**Handler Signature with Auth**:
```rust
async fn create_post(
    user_id: UserId,  // Injected by auth middleware
    State(pool): State<MySqlPool>,
    Json(payload): Json<CreatePostRequest>,
) -> Result<Json<Post>, ApiError>
```

### Public vs Protected Routes

**Public Routes** (no auth middleware):
- POST /api/v1/auth/register
- POST /api/v1/auth/login
- GET /api/v1/posts (list published posts)
- GET /api/v1/posts/:id (view published post)
- GET /api/v1/users/:id (view profile)
- GET /api/v1/users/:id/posts
- GET /api/v1/tags

**Protected Routes** (require auth middleware):
- All POST/PUT/DELETE operations (except register/login)
- GET /api/v1/posts/feed (personalized feed)
- POST /api/v1/posts/:id/like
- POST /api/v1/posts/:id/comments
- GET /api/v1/notifications

---

## Error Handling

### Custom Error Enum

**Location**: `src/utils/error.rs`

**Implementation**:
```rust
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;

#[derive(Debug, thiserror::Error)]
pub enum ApiError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),

    #[error("Not found: {0}")]
    NotFound(String),

    #[error("Unauthorized: {0}")]
    Unauthorized(String),

    #[error("Forbidden: {0}")]
    Forbidden(String),

    #[error("Validation error: {0}")]
    Validation(String),

    #[error("Conflict: {0}")]
    Conflict(String),

    #[error("Internal server error")]
    Internal(#[from] anyhow::Error),
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            ApiError::Database(_) => (StatusCode::INTERNAL_SERVER_ERROR, self.to_string()),
            ApiError::NotFound(msg) => (StatusCode::NOT_FOUND, msg),
            ApiError::Unauthorized(msg) => (StatusCode::UNAUTHORIZED, msg),
            ApiError::Forbidden(msg) => (StatusCode::FORBIDDEN, msg),
            ApiError::Validation(msg) => (StatusCode::BAD_REQUEST, msg),
            ApiError::Conflict(msg) => (StatusCode::CONFLICT, msg),
            ApiError::Internal(_) => (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error".to_string()),
        };

        let body = Json(json!({
            "error": message,
            "status": status.as_u16(),
        }));

        (status, body).into_response()
    }
}
```

### Handler Error Pattern

**MANDATORY**: All handlers return `Result<T, ApiError>`

```rust
async fn get_user(
    Path(user_id): Path<u64>,
    State(pool): State<MySqlPool>,
) -> Result<Json<User>, ApiError> {
    let user = sqlx::query_as!(User, "SELECT * FROM users WHERE id = ?", user_id)
        .fetch_optional(&pool)
        .await?
        .ok_or_else(|| ApiError::NotFound(format!("User not found with id {}", user_id)))?;

    Ok(Json(user))
}
```

### Error Response Format

**MANDATORY**:
```json
{
  "error": "Error message here",
  "status": HTTP_STATUS_CODE
}
```

---

## Request Validation

### Validation Strategy

**MANDATORY**: Use `validator` crate with derive macros

**Location**: Request DTOs in `src/models/*.rs`

**Pattern**:
```rust
use serde::Deserialize;
use validator::Validate;

#[derive(Debug, Deserialize, Validate)]
pub struct CreatePostRequest {
    #[validate(length(min = 1, max = 200, message = "Title must be between 1 and 200 characters"))]
    pub title: String,

    #[validate(length(min = 1, message = "Content cannot be empty"))]
    pub content: String,

    #[validate(length(max = 5, message = "Maximum 5 tags allowed"))]
    pub tag_ids: Option<Vec<u64>>,
}
```

### Validation in Handlers

**Extract and validate**:
```rust
async fn create_post(
    user_id: UserId,
    State(pool): State<MySqlPool>,
    Json(payload): Json<CreatePostRequest>,
) -> Result<Json<Post>, ApiError> {
    // Validate request
    payload.validate()
        .map_err(|e| ApiError::Validation(e.to_string()))?;

    // Process request...
}
```

### Validation Rules from PRD

**MANDATORY Constraints**:

- **Post title**: 1-200 characters
- **Post content**: Minimum 1 character
- **Comment content**: Maximum 1000 characters
- **Username**: Unique, 3-50 characters, alphanumeric + underscore
- **Email**: Valid email format, unique
- **Password**: Minimum 8 characters
- **Display name**: Maximum 100 characters
- **Bio**: Maximum 500 characters (optional)
- **Tags per post**: Maximum 5

---

## CORS Configuration

### CORS Middleware

**Location**: `src/middleware/cors.rs`

**Configuration**:
```rust
use tower_http::cors::{CorsLayer, Any};

pub fn cors_layer() -> CorsLayer {
    let origins = std::env::var("CORS_ORIGINS")
        .unwrap_or_else(|_| "http://localhost:8081,http://localhost:19006".to_string())
        .split(',')
        .map(|s| s.parse().unwrap())
        .collect::<Vec<_>>();

    CorsLayer::new()
        .allow_origin(origins)
        .allow_methods(Any)
        .allow_headers(Any)
        .allow_credentials(true)
        .max_age(Duration::from_secs(3600))
}
```

### Environment Configuration

**.env (Development)**:
```
CORS_ORIGINS=http://localhost:8081,http://localhost:19006
```

**.env (Production)**:
```
CORS_ORIGINS=https://yourdomain.com,https://app.yourdomain.com
```

### Application in main.rs

**MANDATORY**: Apply CORS layer before all routes:
```rust
let app = Router::new()
    .route("/", get(root))
    // ... all routes
    .layer(cors_layer())
    .with_state(pool);
```

---

## Logging Strategy

### Logging Configuration

**Already configured in `main.rs`**:
```rust
tracing_subscriber::registry()
    .with(
        tracing_subscriber::EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| "blog_api=debug,tower_http=debug".into()),
    )
    .with(tracing_subscriber::fmt::layer())
    .init();
```

### Log Levels

**Environment Control**: `RUST_LOG` env var

**Examples**:
```bash
RUST_LOG=debug          # All debug logs
RUST_LOG=info           # Info and above
RUST_LOG=blog_api=debug,sqlx=warn  # blog_api debug, sqlx warnings only
```

### What to Log

**MANDATORY Logging Rules**:

**error!() - Critical failures**:
- Database connection failures
- Unrecoverable errors
- Panic scenarios

**warn!() - Concerning but recoverable**:
- Rate limit hits
- Deprecated endpoint usage
- Pool near exhaustion

**info!() - Important events**:
- Server started/stopped
- User registration/login
- Post created/published
- Authentication failures

**debug!() - Diagnostic information**:
- SQL queries (via tower_http)
- Request/response details
- Middleware execution

### Log Format

**MANDATORY Pattern**:
```rust
info!("User registered successfully: user_id={}, username={}", user_id, username);
error!("Failed to create post: user_id={}, error={}", user_id, err);
debug!("Processing request: method={}, path={}", method, path);
```

### What NOT to Log

**CRITICAL - Never log**:
- Passwords (plaintext or hashed)
- Full JWT tokens
- API secrets
- Sensitive user data (email addresses in production)

---

## Testing Strategy

### Test Organization

```
backend/
├── src/
│   └── **/*.rs         # Unit tests in #[cfg(test)] modules
└── tests/
    ├── integration_tests.rs  # Integration tests
    └── fixtures/             # Test data
```

### Test Levels

#### 1. Unit Tests (HIGH PRIORITY)

**Location**: Same file as code using `#[cfg(test)] mod tests {}`

**Focus Areas**:
- JWT creation/validation (`src/utils/jwt.rs`)
- Password hashing/verification (`src/utils/password.rs`)
- Error handling (`src/utils/error.rs`)
- Validation helpers (`src/utils/validation.rs`)

**Example**:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_password_hash_verify() {
        let password = "test_password123";
        let hash = hash_password(password).unwrap();
        assert!(verify_password(password, &hash).unwrap());
        assert!(!verify_password("wrong_password", &hash).unwrap());
    }
}
```

**Run**: `cargo test`

#### 2. Integration Tests (MEDIUM PRIORITY)

**Location**: `tests/integration_tests.rs`

**Focus Areas**:
- Handler functions with mock database
- Middleware (auth validation)
- Route registration

**Example**:
```rust
#[tokio::test]
async fn test_protected_route_requires_auth() {
    let app = test_app().await;

    let response = app
        .oneshot(Request::builder().uri("/api/v1/posts").body(Body::empty()).unwrap())
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
}
```

**Run**: `cargo test --test integration_tests`

#### 3. API Tests (LOW PRIORITY - Post-MVP)

**Location**: `tests/api_tests.rs` (to be created)

**Focus**: Full HTTP request/response cycles with test database

**Deferred**: Can add after MVP completion

### Test Commands

```bash
# Run all tests
cargo test

# Run specific test
cargo test test_password_hash_verify

# Run with output
cargo test -- --nocapture

# Run integration tests only
cargo test --test integration_tests
```

---

## Connection Pool Configuration

### Database Pool Setup

**Location**: `src/db/mod.rs`

**Implementation**:
```rust
use sqlx::mysql::{MySqlPool, MySqlPoolOptions};
use std::time::Duration;

pub async fn create_pool() -> Result<MySqlPool, sqlx::Error> {
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");

    let max_connections = std::env::var("DATABASE_MAX_CONNECTIONS")
        .unwrap_or_else(|_| "20".to_string())
        .parse::<u32>()
        .expect("DATABASE_MAX_CONNECTIONS must be a number");

    let connect_timeout = std::env::var("DATABASE_CONNECT_TIMEOUT")
        .unwrap_or_else(|_| "30".to_string())
        .parse::<u64>()
        .expect("DATABASE_CONNECT_TIMEOUT must be a number");

    MySqlPoolOptions::new()
        .max_connections(max_connections)
        .min_connections(2)
        .connect_timeout(Duration::from_secs(connect_timeout))
        .idle_timeout(Duration::from_secs(600))
        .acquire_timeout(Duration::from_secs(30))
        .connect(&database_url)
        .await
}
```

### Environment Configuration

**.env**:
```
DATABASE_URL=mysql://username:password@localhost:3306/blog_db
DATABASE_MAX_CONNECTIONS=20
DATABASE_CONNECT_TIMEOUT=30
```

### Pool Usage in main.rs

**MANDATORY**: Create pool once, share via Axum state:
```rust
#[tokio::main]
async fn main() {
    // ... tracing and env setup

    // Create database pool
    let pool = db::create_pool().await.expect("Failed to create database pool");

    // Build router with shared pool
    let app = Router::new()
        // ... routes
        .with_state(pool);

    // ... start server
}
```

### Pool Usage in Handlers

```rust
async fn handler(
    State(pool): State<MySqlPool>,
    // ... other extractors
) -> Result<Json<T>, ApiError> {
    // Use pool for queries
    let result = sqlx::query!("SELECT * FROM users WHERE id = ?", user_id)
        .fetch_one(&pool)
        .await?;

    Ok(Json(result))
}
```

### Pool Exhaustion Handling

**Error mapping**:
```rust
// In ApiError enum
match sqlx_error {
    sqlx::Error::PoolTimedOut => ApiError::ServiceUnavailable("Database pool exhausted"),
    _ => ApiError::Database(sqlx_error),
}
```

**HTTP Status**: Return `503 Service Unavailable` when pool exhausted

---

## Implementation Patterns

### Naming Conventions

#### Rust Code

**MANDATORY Rules**:
- Modules: `snake_case` (e.g., `auth.rs`, `user.rs`)
- Functions: `snake_case` (e.g., `create_post`, `hash_password`)
- Structs/Enums: `PascalCase` (e.g., `User`, `ApiError`)
- Constants: `SCREAMING_SNAKE_CASE` (e.g., `JWT_SECRET`, `MAX_CONNECTIONS`)

#### File Organization

**MANDATORY Rules**:
- Handler files: `src/handlers/{resource}.rs` (e.g., `post.rs`, `user.rs`)
- Route files: `src/routes/{resource}.rs` (matching handlers)
- Model files: `src/models/{resource}.rs` (matching database tables)
- One resource per file
- Use `mod.rs` to re-export public items

#### Database Rust Mapping

**MANDATORY**:
- Rust struct fields: `snake_case` (matching database columns)
- Struct names: `PascalCase` (e.g., `User`, `Post`)
- Use `sqlx::FromRow` derive for database models

**Example**:
```rust
#[derive(sqlx::FromRow, serde::Serialize)]
pub struct User {
    pub id: u64,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub display_name: Option<String>,
    pub bio: Option<String>,
    pub profile_picture_url: Option<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}
```

### Module Structure Pattern

**MANDATORY**: Each module directory has `mod.rs` that re-exports:

```rust
// src/handlers/mod.rs
pub mod auth;
pub mod user;
pub mod post;
pub mod comment;
pub mod like;
pub mod follow;
pub mod notification;
pub mod tag;
```

**Usage in main.rs**:
```rust
mod handlers;
use handlers::{auth, user, post};
```

### Handler Function Pattern

**MANDATORY Signature**:
```rust
async fn handler_name(
    // Extractors in this order:
    // 1. Path parameters
    Path(id): Path<u64>,

    // 2. User ID (if protected route)
    user_id: UserId,

    // 3. Database pool
    State(pool): State<MySqlPool>,

    // 4. Request body (if applicable)
    Json(payload): Json<RequestDTO>,
) -> Result<Json<ResponseDTO>, ApiError> {
    // 1. Validate request
    payload.validate()?;

    // 2. Execute business logic
    let result = sqlx::query!("...").fetch_one(&pool).await?;

    // 3. Transform and return
    Ok(Json(result))
}
```

### Route Registration Pattern

**MANDATORY**: Group routes by resource in `src/routes/{resource}.rs`:

```rust
// src/routes/post.rs
use axum::{Router, routing::{get, post}};
use crate::handlers::post;

pub fn routes() -> Router {
    Router::new()
        .route("/posts", get(post::list_posts).post(post::create_post))
        .route("/posts/:id", get(post::get_post).put(post::update_post).delete(post::delete_post))
        .route("/posts/:id/like", post(post::like_post).delete(post::unlike_post))
        .route("/posts/:id/comments", get(post::get_comments).post(post::create_comment))
}
```

**Combine in main.rs**:
```rust
let app = Router::new()
    .nest("/api/v1", Router::new()
        .merge(routes::auth::routes())
        .merge(routes::user::routes())
        .merge(routes::post::routes())
        // ... other routes
    )
    .layer(cors_layer())
    .with_state(pool);
```

### DTO Pattern

**MANDATORY**: Separate DTOs for requests and responses:

```rust
// Request DTO (validation)
#[derive(Debug, Deserialize, Validate)]
pub struct CreatePostRequest {
    #[validate(length(min = 1, max = 200))]
    pub title: String,

    #[validate(length(min = 1))]
    pub content: String,

    pub cover_image_url: Option<String>,
    pub tag_ids: Option<Vec<u64>>,
}

// Response DTO (serialization)
#[derive(Debug, Serialize)]
pub struct PostResponse {
    pub id: u64,
    pub title: String,
    pub content: String,
    pub author: UserSummary,
    pub like_count: u64,
    pub comment_count: u64,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}
```

---

## Epic to Architecture Mapping

This section maps each PRD epic to specific architectural components, ensuring complete coverage.

### Epic 1: User Authentication & Account Management

**Database Tables**: `users`

**Handlers**: `src/handlers/auth.rs`, `src/handlers/user.rs`
- `register` - Create new user account
- `login` - Authenticate user
- `logout` - Clear session (client-side)
- `forgot_password` - Initiate password reset
- `reset_password` - Complete password reset
- `get_profile` - Get user profile
- `update_profile` - Update user information
- `delete_account` - Soft delete user account

**Routes**: `src/routes/auth.rs`, `src/routes/user.rs`
- POST /api/v1/auth/register
- POST /api/v1/auth/login
- POST /api/v1/auth/logout
- POST /api/v1/auth/forgot-password
- POST /api/v1/auth/reset-password
- GET /api/v1/users/:id
- PUT /api/v1/users/:id
- DELETE /api/v1/users/:id

**Models**: `src/models/user.rs`
- `User` - Database model
- `RegisterRequest` - Registration DTO
- `LoginRequest` - Login DTO
- `UpdateProfileRequest` - Profile update DTO
- `UserResponse` - Public user data

**Middleware**: `src/middleware/auth.rs`
- JWT validation for protected routes

**Utils**: `src/utils/jwt.rs`, `src/utils/password.rs`
- JWT creation and validation
- Password hashing and verification

### Epic 2: Blog Post Creation & Management

**Database Tables**: `posts`, `post_tags`, `tags`

**Handlers**: `src/handlers/post.rs`, `src/handlers/tag.rs`
- `create_post` - Create new post (draft or published)
- `get_post` - Get single post by ID
- `list_posts` - List all published posts (paginated)
- `update_post` - Update existing post
- `delete_post` - Delete post
- `get_user_posts` - Get posts by specific user
- `get_post_feed` - Personalized feed
- `search_posts` - Search by title/content

**Routes**: `src/routes/post.rs`
- GET /api/v1/posts
- GET /api/v1/posts/:id
- POST /api/v1/posts
- PUT /api/v1/posts/:id
- DELETE /api/v1/posts/:id
- GET /api/v1/posts/feed
- GET /api/v1/posts/search

**Models**: `src/models/post.rs`, `src/models/tag.rs`
- `Post` - Database model
- `Tag` - Tag model
- `PostTag` - Junction table model
- `CreatePostRequest` - Post creation DTO
- `UpdatePostRequest` - Post update DTO
- `PostResponse` - Post with author info

### Epic 3: Content Discovery & Feed

**Database Tables**: `posts`, `users`, `follows`

**Handlers**: `src/handlers/post.rs`, `src/handlers/user.rs`
- `get_post_feed` - Chronological feed from followed users
- `list_posts` - Browse all public posts
- `search_posts` - Search functionality
- `get_user_profile` - View user profiles
- `get_user_posts` - View user's posts

**Routes**: Covered in Epic 2 and Epic 1

**Query Optimization**:
- Pagination for all list endpoints
- Indexes on `posts.published_at`, `posts.created_at`
- Join optimization for feed queries

### Epic 4: Social Interactions

**Database Tables**: `likes`, `comments`, `follows`

**Handlers**: `src/handlers/like.rs`, `src/handlers/comment.rs`, `src/handlers/follow.rs`

**Likes**:
- `like_post` - Like a post
- `unlike_post` - Remove like
- `get_post_likes` - Get users who liked post

**Comments**:
- `create_comment` - Add comment to post
- `get_post_comments` - Get comments for post
- `update_comment` - Edit own comment
- `delete_comment` - Delete own comment or as post author
- `create_reply` - Reply to comment (nested)

**Follows**:
- `follow_user` - Follow another user
- `unfollow_user` - Unfollow user
- `get_followers` - Get user's followers
- `get_following` - Get users being followed

**Routes**: `src/routes/like.rs`, `src/routes/comment.rs`, `src/routes/follow.rs`
- POST /api/v1/posts/:id/like
- DELETE /api/v1/posts/:id/like
- GET /api/v1/posts/:id/likes
- GET /api/v1/posts/:id/comments
- POST /api/v1/posts/:id/comments
- PUT /api/v1/comments/:id
- DELETE /api/v1/comments/:id
- POST /api/v1/users/:id/follow
- DELETE /api/v1/users/:id/follow
- GET /api/v1/users/:id/followers
- GET /api/v1/users/:id/following

**Models**: `src/models/like.rs`, `src/models/comment.rs`, `src/models/follow.rs`

### Epic 5: Notifications

**Database Tables**: `notifications`

**Handlers**: `src/handlers/notification.rs`
- `get_user_notifications` - Get user's notifications (paginated)
- `mark_notification_read` - Mark single notification as read
- `mark_all_read` - Mark all notifications as read
- `create_notification` - Helper function called by other handlers

**Routes**: `src/routes/notification.rs`
- GET /api/v1/notifications
- PUT /api/v1/notifications/:id/read
- PUT /api/v1/notifications/read-all

**Models**: `src/models/notification.rs`
- `Notification` - Database model
- `NotificationResponse` - With actor details

**Trigger Points** (create notification when):
- User likes post → Notify post author
- User comments on post → Notify post author
- User follows another user → Notify followed user
- User replies to comment → Notify parent comment author

---

## Security Architecture

### Password Security

**Hashing Algorithm**: bcrypt with cost factor 12

**Implementation**: `src/utils/password.rs`
```rust
use bcrypt::{hash, verify, DEFAULT_COST};

pub fn hash_password(password: &str) -> Result<String, bcrypt::BcryptError> {
    hash(password, DEFAULT_COST)
}

pub fn verify_password(password: &str, hash: &str) -> Result<bool, bcrypt::BcryptError> {
    verify(password, hash)
}
```

**Password Requirements** (validation):
- Minimum 8 characters
- Maximum 128 characters (bcrypt limit)
- Mix of letters, numbers, special characters (recommended but not enforced in MVP)

### JWT Security

**Token Storage** (Client-side):
- Use `expo-secure-store` on mobile (encrypted storage)
- Use `HttpOnly` cookies for web (future enhancement)
- Never store in localStorage

**Token Transmission**:
- Always use HTTPS in production
- Send via `Authorization: Bearer <token>` header
- Never send in URL query parameters

**Token Expiration**:
- 24-hour lifespan (configurable)
- No automatic refresh in MVP
- User must re-login after expiration

### SQL Injection Prevention

**MANDATORY**: Use sqlx parameterized queries ONLY

**Correct**:
```rust
sqlx::query!("SELECT * FROM users WHERE id = ?", user_id)
    .fetch_one(&pool)
    .await?
```

**NEVER do**:
```rust
// WRONG - SQL injection vulnerability
let query = format!("SELECT * FROM users WHERE id = {}", user_id);
sqlx::query(&query).fetch_one(&pool).await?
```

### Input Validation

**All user inputs MUST be validated**:
- Use `validator` crate for automatic validation
- Sanitize HTML content in posts/comments (future: use crate like `ammonia`)
- Validate file uploads (if image upload feature added)

### Rate Limiting

**Future Enhancement** (post-MVP):
- Implement rate limiting middleware with `tower-governor`
- Limit login attempts: 5 per 15 minutes per IP
- Limit API calls: 100 per minute per user

### HTTPS/TLS

**Production Deployment**:
- MUST use HTTPS for all API calls
- Use reverse proxy (nginx) with TLS termination
- Redirect HTTP to HTTPS

---

## Performance Considerations

### Database Query Optimization

**Indexes** (from schema):
- `users.username` - For login and profile lookups
- `users.email` - For login and uniqueness checks
- `posts.author_id` - For user's posts queries
- `posts.status` - For filtering published posts
- `posts.published_at` - For chronological feeds
- `likes.post_id` + `likes.user_id` - For like counting and checking
- `follows.follower_id` + `follows.following_id` - For feed generation
- `comments.post_id` - For fetching post comments
- `notifications.user_id` + `notifications.is_read` - For notification queries

**Query Guidelines**:
- Use `LIMIT` and `OFFSET` for pagination
- Avoid N+1 queries (use JOINs or batch queries)
- Use `COUNT(*)` sparingly (cache results when possible)
- Index foreign keys

### Pagination

**MANDATORY for list endpoints**:
```rust
#[derive(Deserialize)]
pub struct PaginationParams {
    #[serde(default = "default_page")]
    pub page: u32,

    #[serde(default = "default_limit")]
    pub limit: u32,
}

fn default_page() -> u32 { 1 }
fn default_limit() -> u32 { 20 }

// Calculate offset
let offset = (page - 1) * limit;

// Query with pagination
sqlx::query!("SELECT * FROM posts LIMIT ? OFFSET ?", limit, offset)
```

**Response format**:
```json
{
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 150,
    "total_pages": 8
  }
}
```

### Caching Strategy

**Future Enhancement** (post-MVP):
- Cache frequently accessed data (user profiles, popular posts)
- Use Redis for session storage and caching
- Implement cache invalidation on updates

### Connection Pool Tuning

**Production Settings**:
```
DATABASE_MAX_CONNECTIONS=50  # Adjust based on server resources
DATABASE_CONNECT_TIMEOUT=30
```

**Monitoring**:
- Track pool usage metrics
- Alert on pool exhaustion
- Scale connections based on load

---

## Development Environment

### Prerequisites

**Required**:
- Rust 1.70+ (`rustup install stable`)
- MySQL 8.0+ (`brew install mysql` on macOS)
- Node.js 20+ (for frontend, not backend)

**Optional but Recommended**:
- `cargo-watch` for auto-reload: `cargo install cargo-watch`
- `sqlx-cli` for migrations: `cargo install sqlx-cli --no-default-features --features mysql`

### Environment Setup

1. **Clone repository**
2. **Create .env file**:
   ```bash
   cd backend
   cp .env.example .env
   # Edit .env with your database credentials
   ```

3. **Create database**:
   ```bash
   mysql -u root -p
   CREATE DATABASE blog_db;
   EXIT;
   ```

4. **Run migrations**:
   ```bash
   sqlx migrate run
   ```

5. **Start development server**:
   ```bash
   cargo run
   # Or with auto-reload:
   cargo watch -x run
   ```

### Environment Variables

**Required**:
```bash
DATABASE_URL=mysql://username:password@localhost:3306/blog_db
JWT_SECRET=your-secret-key-change-in-production
JWT_EXPIRATION=86400
PORT=8080
RUST_LOG=blog_api=debug,tower_http=debug
```

**Optional**:
```bash
DATABASE_MAX_CONNECTIONS=20
DATABASE_CONNECT_TIMEOUT=30
CORS_ORIGINS=http://localhost:8081,http://localhost:19006
```

### Development Commands

```bash
# Run server
cargo run

# Run with auto-reload
cargo watch -x run

# Run tests
cargo test

# Check for compilation errors
cargo check

# Format code
cargo fmt

# Lint code
cargo clippy

# Build for production
cargo build --release

# Database migrations
sqlx migrate add <name>
sqlx migrate run
sqlx migrate revert
```

---

## Architecture Decision Records

### ADR-001: Use Axum instead of Actix-web

**Context**: Need to choose web framework for Rust API

**Decision**: Use Axum 0.7

**Rationale**:
- Built on tokio and tower (mature ecosystem)
- Type-safe extractors (compile-time guarantees)
- Excellent middleware support
- Active development and community
- Simpler than Actix-web for this use case

**Consequences**:
- Requires tokio async runtime (already decided)
- Less mature than Actix-web but sufficient for MVP

### ADR-002: Use sqlx instead of Diesel ORM

**Context**: Need database library for MySQL

**Decision**: Use sqlx with compile-time query checking

**Rationale**:
- Compile-time SQL verification
- No code generation needed
- Async/await native support
- Lighter weight than full ORM
- Direct SQL control for complex queries

**Consequences**:
- Write SQL manually (not ORM methods)
- Requires `DATABASE_URL` at compile time
- More control but less abstraction

### ADR-003: JWT-only authentication (no refresh tokens in MVP)

**Context**: Need authentication mechanism

**Decision**: JWT with 24-hour expiration, no refresh tokens

**Rationale**:
- Simpler implementation for MVP
- Stateless authentication
- 24 hours is reasonable for blog platform
- Can add refresh tokens post-MVP if needed

**Consequences**:
- Users must re-login every 24 hours
- No token revocation (logout is client-side only)
- Simpler backend, less secure than refresh token pattern

### ADR-004: bcrypt for password hashing

**Context**: Need secure password hashing

**Decision**: Use bcrypt with cost factor 12

**Rationale**:
- Industry standard
- Adaptive cost factor (future-proof)
- Resistant to brute-force attacks
- Well-tested Rust implementation

**Consequences**:
- Slower than alternatives (by design)
- Password limited to 72 bytes
- Good security/performance balance

### ADR-005: RESTful API over GraphQL

**Context**: API architecture style

**Decision**: RESTful API with JSON

**Rationale**:
- Simpler for MVP
- Well-understood by frontend developers
- Standard HTTP methods and status codes
- Easier to cache and debug
- Mobile app requirements fit REST model

**Consequences**:
- Multiple requests for related data (no single query like GraphQL)
- Fixed response shapes (less flexible)
- Standard approach, easier to maintain

### ADR-006: Layered architecture (models/handlers/routes)

**Context**: Code organization pattern

**Decision**: Three-layer architecture with clear separation

**Rationale**:
- Clear separation of concerns
- Easy to locate code by function
- Standard Rust web pattern
- Testable layers
- Scalable for team development

**Consequences**:
- More files/directories
- Must maintain consistency across layers
- Clear boundaries make changes easier

### ADR-007: Soft delete for users, hard delete for content

**Context**: Deletion strategy

**Decision**:
- Soft delete users (`deleted_at` timestamp)
- Hard delete posts/comments/etc.

**Rationale**:
- User data privacy compliance
- Keep user IDs valid for foreign key integrity
- Content associated with deleted users is also deleted (CASCADE)
- No need to preserve deleted content

**Consequences**:
- Queries must filter `WHERE deleted_at IS NULL`
- User accounts can be recovered within grace period
- Content deletion is permanent

### ADR-008: Embedded tests over separate test directory for units

**Context**: Where to put unit tests

**Decision**: Use `#[cfg(test)] mod tests {}` in same file as code

**Rationale**:
- Tests live next to code they test
- Private function testing without `pub` exposure
- Standard Rust pattern
- Easier to maintain

**Consequences**:
- Slightly larger source files
- Integration tests still in `tests/` directory

---

## Summary

This architecture provides a complete blueprint for implementing the Blog Backend API. All architectural decisions are **MANDATORY** and must be followed by all AI agents implementing features.

### Key Takeaways

1. **Database**: MySQL with sqlx migrations, snake_case naming
2. **Authentication**: JWT tokens (24h), bcrypt passwords, auth middleware
3. **API**: RESTful with direct responses, standard HTTP codes
4. **Errors**: Custom enum with thiserror, structured error responses
5. **Validation**: validator crate with derive macros
6. **Logging**: tracing crate with RUST_LOG control
7. **Testing**: Unit tests (high priority), integration tests (medium)
8. **Structure**: Layered architecture (models/handlers/routes)

### Next Steps

After architecture approval:
1. **Solutioning gate check** - Validate architecture completeness
2. **Sprint planning** - Create sprint-status.yaml with all stories
3. **Implementation** - Begin iterative story development

---

**Document Status**: Complete ✅
**Ready for**: Solutioning Gate Check → Implementation Phase
**Generated by**: BMAD Method v6 - Decision Architecture Workflow
